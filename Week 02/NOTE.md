学习笔记

寻路问题：广度优先遍历，深度优先遍历

广度优先，就是把所有可达的节点放进队列，根据先入先出的队列特性，来保证，最先触达的点，最先访问，保证了广度优先。
push / shift

深度优先，就是把所有可达的节点放进队列，根据后入先出的队列特性，来保证，最后触达的点，最先访问，保证了深度优先。
push / pop

- 寻路BFS实现：
  1. 实现地图编辑器：展示地图，左击设置障碍，右击清除障碍
  2. 广度优先搜索实现寻路算法：打印搜索坐标，到达end返回true，否则返回false
  3. 通过异步sleep实现可视化寻路算法：insert时为对应坐标的点添加背景色标记
  4. 处理路径问题：insert点到queue中时，保存pre坐标，到end后根据pre反向寻找start

- 寻路A*实现：  
将上面的广搜替换为启发式搜索：数据结构由queue替换为Sorted结构，每次取出的点是当前所有点中距离end最近的点，减少搜索范围

- 寻路最短路径实现：  
处理路径问题时，反向寻找的pre不一定是最优的pre，所以在一开始insert点保存pre时需要作处理：
  1. insert点时，记录start到每个[x, y]点的路径长度，保存在cost对象中，key为数组下标
  2. insert(x, y, pre)时，若[x, y]已经保存了pre'和cost'，则比较[x, y]到start的新旧两条路径的cost，若新的比旧的优，则用pre替换[x, y]中的pre'

- 寻路二叉堆实现：  
  - 将数据结构由Sorted结构替换为BH，因为每次要取离end最近的点搜索，所以采用MinBH来实现，即BH中的root为compare最小的点
  - Sorted的take方法的时间复杂度为O(n)，而BH的take的时间复杂度为O(log<sub>2</sub>n)，故MinBH的效率比Sorted结构的高
  - 使用数组表示BH，给定位置index的节点：
    - 左侧子节点的位置 2 * index + 1
    - 右侧子节点的位置 2 * index + 2
    - 父节点的位置 Math.floor((i - 1) / 2)
  1. insertAt将v加在BH的最后，然后由下向上，通过与父节点的层层对比和替换，保证insert后，最小的点始终为root节点
  2. take方法将root节点的点取出，然后由上向下，通过左右节点的比较，层层向下，将左右节点中小的往父节点移
  3. 拷贝到父节点的子节点若为最后一个叶子节点，则直接移除最后一个叶子节点；否则将最后一个叶子节点填充空位后，再将最后一个叶子节点移除

