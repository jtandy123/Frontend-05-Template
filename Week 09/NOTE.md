学习笔记

第一步：拆分文件  
从request得到response  
把response的body交给parser去处理  
真正的浏览器是逐段的返回response的body，然后逐段的去给parser处理，即做成异步分段处理
* 为了方便文件管理，把parser单独拆到文件中
* parser接受HTML文本作为参数，返回一颗DOM树

第二步：用FSM实现HTML分析  
解析HTML这种文本类的操作，一定会用到状态机  
首先需要创建一个状态机  
在创建状态机之前，首先要知道HTML的语法  

HTML标准里已经把整个状态机全都设计好了  
一共80个状态  
* 用FSM来实现HTML的分析
* 在HTML标准中，已经规定了HTML的状态
* Toy-Browser只挑选其中一部分状态，完成一个最简版本

第三步：解析标签  
HTML里面的标签分为3种：  
* 开始标签
* 结束标签
* 自封闭标签

第四步：创建元素  
* 在状态机中，除了状态迁移，还要加入业务逻辑
* 在标签结束状态提交标签token

第五步：处理属性  
* 属性值分为单引号、双引号、无引号三种写法，因此需要较多状态处理
* 处理属性的方式跟标签类似
* 属性结束时，把属性加到标签token上

使用状态机对HTML进行初步解析，在编译原理上称为词法分析。接下来就是HTML的语法分析  
用栈来进行HTML的语法分析

第六步：用token构建DOM树，Tree Construction  
* 从标签构建DOM树的基本技巧是使用栈
* 遇到开始标签时创建元素并入栈，遇到结束标签时出栈
* 自封闭节点可视为入栈后立刻出栈
* 任何元素的父元素是它入栈前的栈顶

第七步：将文本节点加到DOM树  
* 文本节点与自封闭标签处理类似，并不会真的入栈
* 多个文本节点需要合并

至此，完成了HTML的解析  

CSS Computing, 得到一颗带CSS的DOM树  
环境准备：  
```
npm install css
```
CSS parser, 将CSS代码变成AST   
根据AST抽出对应的CSS规则，并且把它们应用到HTML元素上   
CSS Computing发生在DOM树的构建过程当中  

第一步：收集CSS规则
* 遇到style标签时，把CSS规则保存起来
* 调用CSS Parser（css库）来分析CSS规则
* 需要仔细研究css库分析CSS规则的格式

第二步：添加调用  
CSS设计会尽量保证所有的选择器都能够在startTag进入的时候就能够被判断。加入高级的选择器之后，这个规则有了一定的松动，但是大部分的规则仍然是去遵循这个规则的。当DOM树构建到你的元素的startTag的步骤就已经可以判断出来它能匹配哪些CSS规则了  
* 当创建一个元素后，立即计算CSS
* 理论上，当分析一个元素时，所有CSS规则已经收集完毕
* 在真实浏览器中，可能遇到写在body的style标签，需要重新CSS计算的情况，这里先忽略

第三步：获取父元素序列  
* 在computeCSS函数中，必须知道元素的所有父元素才能判断元素与规则是否匹配
* 从上一步骤的stack，可以获取本元素所有的父元素
* 因为首先获取的是“当前元素”，所以获得和计算父元素匹配的顺序是从内向外

第四步：选择器与元素的匹配  
选择器的层级结构：  
* 最外层为选择器列表 - CSS parser已经做了拆分
* 选择器列表内为复杂选择器，复杂选择器是由空格分割的一系列的复合选择器
* 复杂选择器是根据亲代关系去选择元素的
* 复合选择器是针对一个元素的本身的属性和特征的一个判断
* 复合选择器是由紧连着的一堆简单选择器而构成

选择器要从当前元素向外排列  
复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列  

第五步：计算选择器与元素匹配  
* 根据选择器的类型和元素属性，计算是否与当前元素匹配
* 仅仅实现了三种基本选择器，实际的浏览器中要处理复合选择器
* 实现复合选择器
* 实现支持空格的Class选择器

第六步：生成computed属性  
CSS Rules里面有declarations声明的属性，只需要把声明的属性一条一条的作用到元素的computed的属性上面就可以了  
* 一旦选择匹配，就应用选择器到元素上，形成computedStyle

第七步：specificity的计算逻辑  
CSS 优先级的计算逻辑  

specificity的计算是根据单个的复杂选择器去加起来去计算的  
四元组  
[0,    0,  0,    0]   
inline id  class tag  

div div #id  
[0, 1, 0, 2]  
div #my #id  
[0, 2, 0, 1]  

两个函数：一个计算specificity，一个比较specificity  

* CSS规则根据specificity和后来优先规则覆盖
* specificity是个四元组，越左边权重越高
* 一个CSS规则的specificity根据包含的简单选择器相加而成
