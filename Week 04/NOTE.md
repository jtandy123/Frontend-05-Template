学习笔记

字符串分析算法（由易到难）
* 字典树
    * 大量高重复字符串的存储与分析
* KMP
    * 在长字符串里找模式
* Wildcard
    * 带通配符的字符串模式
* 正则
    * 字符串通用模式匹配
* 状态机
    * 通用的字符串分析
* LL LR
    * 字符串多层级结构分析

字典树是用来精确的匹配字符串跟模式的，两个字符串精确相等比较。例如：1亿字符串，出现频率前50的数量的字符串   
字符串不是太长，例如搜索关键词   
字典树是哈希树的一种特例   
哈希树在字符串领域最直接的应用的体现就是字典树   
如果是处理数字，可以用别的哈希算法构造别的哈希树   
   
算法：
- 构造字典，使用Object来表示字典tree结构
- 查询字典，使用递归去遍历tree，寻早最大、最小

KMP 两个字符串，一个字符串是另一个字符串的部分，部分匹配   
字符串模式匹配   
一个长度为m的字符串和一个长度为n的字符串，互相匹配，最笨的办法可能是一个O(m*n)的时间复杂度   
KMP的复杂度为O(m + n)   
Brute-Force(BF)，暴力解法，时间复杂度m * n   

算法：
* 求跳转表格PMT：pattern自己与自己匹配
* 进行真正的匹配：source与pattern进行匹配，匹配失败时，source的指针不动，pattern的指针根据PMT进行移动

Wildcard在KMP的基础上又加了通配符(问号，星号等)，问号就是表示匹配任意字符，星号表示匹配任意数量的任意字符   
例如文件查找可能会用到Wildcard，可以理解为弱一点的正则表达式，因为它只有两种通配符   
Wildcard的时间复杂度为O(n)或者O(m+n)，使用贪心算法  
*是尽量少匹配还是尽量多匹配？

算法：
* 统计pattern中的星号数量，若没有星号，按位比较source与pattern
* 头部：开始匹配第一个星号之前的部分
* 中部：开始匹配第一个星号开始到最后一个星号之前的部分：分成多组，每组以星号开头到下一个星号之前的内容
* 尾部：最后一个星号可以尽可能多的匹配，所以只要匹配最后一个星号之后的内容，并且从最后往前匹配

>思考：带?的KMP算法去替代   
pattern的指针根据PMT进行移动后的位置如果是？，需要进行处理，可再次移动pattern的指针

正则一般来说是一个需要用到回溯系统   
字符串模式匹配的一个终极版本

状态机  
正则表达式跟有限状态机理论上是完全等价的   
不同的是有限状态机还可以往里面嵌代码，还可以去对字符串做额外处理   
正则写起来比较方便，有限状态机写起来成本比较高，还需要一定的设计

LL LR  
在对字符串简单匹配和分析的基础上，要对字符串建立起来多层级的结构，就会使用LL和LR

LR比LL更加强大的语法分析，简单写就用LL，LR理论性比较强   
HTML的语法分析，用stack去处理，LR算法的一个简化版，LR(0)的语法   
一般处理都会用LR(1)，LR(1)可以等于到LL(n)的强大的分析算法  
编译原理内容
